name: ðŸŽ¬ Ø±ÙØ¹ ÙÙŠÙ„Ù… - Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ

on:
  workflow_dispatch:
    inputs:
      channel_link:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø©'
        required: true
        type: string
      movie_name:
        description: 'Ø§Ø³Ù… Ø§Ù„ÙÙŠÙ„Ù…'
        required: true
        type: string
      poster_url:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨ÙˆØ³ØªØ±'
        required: true
        type: string
      video_url:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø¨Ø§Ø´Ø± mp4'
        required: true
        type: string

jobs:
  upload:
    runs-on: ubuntu-latest
    timeout-minutes: 120

    steps:
    - name: ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
      run: |
        sudo apt update
        sudo apt install -y python3 python3-pip wget ffmpeg
        pip3 install telethon requests

    - name: Ø¥Ù†Ø´Ø§Ø¡ Ø³ÙƒØ±Ø¨Øª Ø§Ù„Ø±ÙØ¹
      run: |
        cat > upload.py << 'EOF'
        import asyncio, os, subprocess, sys, requests, logging
        
        logging.basicConfig(level=logging.INFO)
        logger = logging.getLogger(__name__)
        
        from telethon import TelegramClient, types
        from telethon.sessions import StringSession

        API_ID = int(os.environ['TELEGRAM_API_ID'])
        API_HASH = os.environ['TELEGRAM_API_HASH']
        SESSION = os.environ['TELEGRAM_SESSION_STRING']

        CHANNEL = os.environ['CHANNEL_LINK']
        MOVIE = os.environ['MOVIE_NAME']
        POSTER_URL = os.environ['POSTER_URL']
        VIDEO_URL = os.environ['VIDEO_URL']

        POSTER = "poster.jpg"
        VIDEO = "video.mp4"

        def download_file(url, out):
            """ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª Ø¨Ø´ÙƒÙ„ Ù…ÙˆØ«ÙˆÙ‚"""
            try:
                logger.info(f"ðŸ“¥ Ø¬Ø§Ø±ÙŠ ØªØ­Ù…ÙŠÙ„ {url}")
                response = requests.get(url, stream=True, timeout=30)
                response.raise_for_status()
                
                with open(out, 'wb') as f:
                    for chunk in response.iter_content(chunk_size=8192):
                        if chunk:
                            f.write(chunk)
                
                file_size = os.path.getsize(out) / (1024*1024)
                logger.info(f"âœ… ØªÙ… ØªØ­Ù…ÙŠÙ„ {out} - Ø§Ù„Ø­Ø¬Ù…: {file_size:.2f} MB")
                return True
                
            except Exception as e:
                logger.error(f"âŒ ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ {out}: {e}")
                return False

        def check_video(path):
            """ÙØ­Øµ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ"""
            if not os.path.exists(path):
                raise Exception("Ø§Ù„Ù…Ù„Ù ØºÙŠØ± Ù…ÙˆØ¬ÙˆØ¯")
            
            size = os.path.getsize(path)
            if size < 5 * 1024 * 1024:
                raise Exception(f"Ø§Ù„Ù…Ù„Ù ØµØºÙŠØ± Ø¬Ø¯Ø§Ù‹: {size/1024/1024:.2f} MB")
            
            logger.info(f"ðŸ“Š Ø­Ø¬Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {size/1024/1024:.2f} MB")
            
            # ÙØ­Øµ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… ffprobe
            try:
                cmd = ["ffprobe", "-v", "error", "-select_streams", "v:0",
                       "-count_frames", "-show_entries", "stream=codec_type,duration,width,height",
                       "-of", "csv=p=0", path]
                result = subprocess.run(cmd, capture_output=True, text=True, timeout=30)
                
                if "video" not in result.stdout:
                    raise Exception("Ø§Ù„Ù…Ù„Ù Ù„ÙŠØ³ ÙÙŠØ¯ÙŠÙˆ")
                
                logger.info(f"ðŸ” Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {result.stdout.strip()}")
                
            except subprocess.TimeoutExpired:
                logger.warning("ÙØ­Øµ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ØªØ¬Ø§ÙˆØ² Ø§Ù„Ù…Ù‡Ù„Ø©ØŒ Ù„ÙƒÙ† Ø³Ù†Ø³ØªÙ…Ø±")
            except Exception as e:
                logger.warning(f"ÙØ­Øµ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {e}")

        async def main():
            logger.info("ðŸš€ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±ÙØ¹...")
            
            # ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª
            if not download_file(POSTER_URL, POSTER):
                raise Exception("ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©")
            
            if not download_file(VIDEO_URL, VIDEO):
                raise Exception("ÙØ´Ù„ ØªØ­Ù…ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ")
            
            check_video(VIDEO)
            
            # Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…
            logger.info("ðŸ”— Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ø§Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…...")
            client = TelegramClient(StringSession(SESSION), API_ID, API_HASH)
            await client.connect()
            
            if not await client.is_user_authorized():
                raise Exception("Ø¬Ù„Ø³Ø© ØªÙ„ÙŠØ¬Ø±Ø§Ù… ØºÙŠØ± ØµØ§Ù„Ø­Ø©")
            
            logger.info(f"âœ… ØªÙ… Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ {await client.get_me().username}")
            
            # Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†Ø§Ø©
            channel = await client.get_entity(CHANNEL)
            logger.info(f"ðŸ“¢ Ø§Ù„Ù‚Ù†Ø§Ø©: {channel.title}")
            
            # Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©
            logger.info("â¬†ï¸ Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...")
            photo = await client.upload_file(POSTER)
            
            # Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
            logger.info("â¬†ï¸ Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...")
            video = await client.upload_file(
                VIDEO,
                part_size_kb=512,  # Ø­Ø¬Ù… Ø§Ù„Ù‚Ø·Ø¹ Ù„Ù„Ø±ÙØ¹
                file_size=os.path.getsize(VIDEO)
            )
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙˆØ³Ø§Ø¦Ø· Ø§Ù„Ù…ØªØ¹Ø¯Ø¯Ø©
            logger.info("ðŸ“¤ Ø¬Ø§Ø±ÙŠ Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„ÙˆØ³Ø§Ø¦Ø·...")
            media = [
                types.InputMediaUploadedPhoto(
                    file=photo,
                    caption=f"ðŸŽ¬ {MOVIE}"
                ),
                types.InputMediaUploadedDocument(
                    file=video,
                    mime_type="video/mp4",
                    attributes=[
                        types.DocumentAttributeVideo(
                            supports_streaming=True,
                            duration=0,
                            w=0,
                            h=0
                        )
                    ],
                    caption=f"ðŸŽ¥ {MOVIE}\nâœ… ÙÙŠÙ„Ù… ÙƒØ§Ù…Ù„\nðŸ“Š Ø§Ù„Ø­Ø¬Ù…: {os.path.getsize(VIDEO)/1024/1024:.2f} MB"
                )
            ]
            
            # Ø¥Ø±Ø³Ø§Ù„ Ø§Ù„Ø±Ø³Ø§Ù„Ø©
            message = await client.send_message(
                channel,
                file=media,
                parse_mode='html'
            )
            
            logger.info(f"âœ… ØªÙ… Ø§Ù„Ø±ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­! Ø§Ù„Ø±Ø³Ø§Ù„Ø© ID: {message.id}")
            await client.disconnect()

        if __name__ == "__main__":
            try:
                asyncio.run(main())
                print("ðŸŽ‰ ØªÙ…Øª Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø¨Ù†Ø¬Ø§Ø­!")
                sys.exit(0)
            except Exception as e:
                logger.error(f"âŒ Ø®Ø·Ø£: {e}")
                sys.exit(1)
        EOF

    - name: ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±ÙØ¹
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION_STRING: ${{ secrets.TELEGRAM_SESSION_STRING }}
        CHANNEL_LINK: ${{ github.event.inputs.channel_link }}
        MOVIE_NAME: ${{ github.event.inputs.movie_name }}
        POSTER_URL: ${{ github.event.inputs.poster_url }}
        VIDEO_URL: ${{ github.event.inputs.video_url }}
      run: |
        python3 upload.py

    - name: Ø¥Ø¸Ù‡Ø§Ø± Ø§Ù„Ù†ØªÙŠØ¬Ø©
      if: always()
      run: |
        echo "ðŸ Workflow completed!"
        echo "ðŸ“Š View logs above for details"
