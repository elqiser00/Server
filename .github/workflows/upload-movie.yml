# .github/workflows/upload-movie-final.yml
name: ğŸ¬ Ø±ÙØ¹ ÙÙŠÙ„Ù… - Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ

on:
  workflow_dispatch:
    inputs:
      channel_link:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø©'
        required: true
        default: 'https://t.me/+VvLRMffUCXNlNjRk'
        type: string
      movie_name:
        description: 'Ø§Ø³Ù… Ø§Ù„ÙÙŠÙ„Ù…'
        required: true
        default: 'Truth & Treason 2025'
        type: string
      poster_url:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„Ø¨ÙˆØ³ØªØ±'
        required: true
        default: 'https://img.downet.net/uploads/U8xQf.webp'
        type: string
      video_url:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ (.mp4)'
        required: true
        type: string

jobs:
  upload:
    runs-on: ubuntu-latest
    timeout-minutes: 90
    
    steps:
    - name: ğŸ“‹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø·Ù„Ø¨
      run: |
        echo "========================================"
        echo "ğŸ¬ Ø±ÙØ¹ ÙÙŠÙ„Ù… ÙƒØ§Ù…Ù„ - Ø§Ù„Ø¥ØµØ¯Ø§Ø± Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ"
        echo "========================================"
        echo "Ø§Ù„ÙÙŠÙ„Ù…: ${{ github.event.inputs.movie_name }}"
        echo "Ø§Ù„Ù‚Ù†Ø§Ø©: ${{ github.event.inputs.channel_link }}"
        echo "Ø§Ù„Ø¨ÙˆØ³ØªØ±: ${{ github.event.inputs.poster_url }}"
        echo "Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: ${{ github.event.inputs.video_url }}"
        echo "========================================"
    
    - name: âš™ï¸ ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip wget
        pip3 install telethon --quiet
        
    - name: ğŸ“ Ø¥Ù†Ø´Ø§Ø¡ Ø³ÙƒØ±Ø¨Øª Ø§Ù„Ø±ÙØ¹ Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠ
      run: |
        cat > upload_final.py << 'EOF'
        import asyncio
        import os
        import sys
        import subprocess
        import time
        import re
        from telethon import TelegramClient, types
        from telethon.sessions import StringSession
        from telethon.tl.functions.messages import SendMultiMediaRequest
        from telethon.tl.types import InputMediaUploadedPhoto, InputMediaUploadedDocument
        
        print("ğŸ¬ Telegram Movie Uploader - Final Version")
        print("=" * 60)
        
        class MovieUploader:
            def __init__(self):
                self.client = None
                self.uploaded_files = []
                
            async def download_file(self, url, filename, max_retries=3):
                for attempt in range(max_retries):
                    try:
                        print(f"â¬‡ï¸  Ù…Ø­Ø§ÙˆÙ„Ø© ØªÙ†Ø²ÙŠÙ„ {filename} ({attempt + 1}/{max_retries})...")
                        
                        cmd = [
                            'wget',
                            '--no-check-certificate',
                            '--timeout=60',
                            '--tries=3',
                            '--waitretry=5',
                            '--retry-connrefused',
                            '--user-agent=Mozilla/5.0',
                            '-O', filename,
                            url
                        ]
                        
                        result = subprocess.run(cmd, capture_output=True, text=True)
                        
                        if result.returncode == 0 and os.path.exists(filename):
                            size = os.path.getsize(filename)
                            print(f"âœ… ØªÙ… ØªÙ†Ø²ÙŠÙ„ {filename} ({size:,} Ø¨Ø§ÙŠØª)")
                            return True
                            
                    except Exception as e:
                        print(f"âŒ Ø®Ø·Ø£: {e}")
                    
                    if attempt < max_retries - 1:
                        print("â³ Ø§Ù†ØªØ¸Ø§Ø± 5 Ø«ÙˆØ§Ù†...")
                        await asyncio.sleep(5)
                
                return False
            
            def clean_filename(self, name, max_length=60):
                name = re.sub(r'[<>:"/\\|?*]', '', name)
                name = re.sub(r'\s+', ' ', name)
                if len(name) > max_length:
                    name = name[:max_length-3] + "..."
                return name.strip()
            
            async def connect_telegram(self, api_id, api_hash, session_string):
                print("\nğŸ”Œ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Telegram...")
                
                try:
                    self.client = TelegramClient(
                        StringSession(session_string),
                        api_id,
                        api_hash,
                        connection_retries=3
                    )
                    
                    await self.client.connect()
                    
                    if not await self.client.is_user_authorized():
                        print("âŒ Ø§Ù„Ø¬Ù„Ø³Ø© ØºÙŠØ± ØµØ§Ù„Ø­Ø©!")
                        return False
                    
                    me = await self.client.get_me()
                    print(f"âœ… Ù…ØªØµÙ„ ÙƒÙ€: {me.first_name} (@{me.username})")
                    return True
                    
                except Exception as e:
                    print(f"âŒ Ø®Ø·Ø£: {e}")
                    return False
            
            async def upload_as_album(self, channel, poster_path, video_path, movie_name, video_filename):
                print("\nğŸ“¦ Ù…Ø­Ø§ÙˆÙ„Ø© Ø§Ù„Ø±ÙØ¹ ÙƒØ£Ù„Ø¨ÙˆÙ…...")
                
                try:
                    print("ğŸ“¸ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...")
                    photo_upload = await self.client.upload_file(
                        poster_path,
                        part_size_kb=512
                    )
                    
                    print("ğŸ¥ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...")
                    video_upload = await self.client.upload_file(
                        video_path,
                        part_size_kb=512,
                        file_name=video_filename
                    )
                    
                    media = [
                        InputMediaUploadedPhoto(
                            file=photo_upload,
                            caption=f"ğŸ¬ {movie_name} - Ø¨ÙˆØ³ØªØ±"
                        ),
                        InputMediaUploadedDocument(
                            file=video_upload,
                            mime_type='video/mp4',
                            attributes=[
                                types.DocumentAttributeVideo(
                                    duration=0,
                                    w=0,
                                    h=0,
                                    round_message=False,
                                    supports_streaming=True
                                )
                            ],
                            caption=f"ğŸ¥ {movie_name}\nğŸ“ {video_filename}\nâœ… ÙÙŠÙ„Ù… ÙƒØ§Ù…Ù„"
                        )
                    ]
                    
                    await self.client(SendMultiMediaRequest(
                        peer=channel,
                        multi_media=media,
                        silent=None,
                        schedule_date=None,
                        reply_to=None
                    ))
                    
                    print("âœ… ØªÙ… Ø§Ù„Ø±ÙØ¹ ÙƒØ£Ù„Ø¨ÙˆÙ…!")
                    return True
                    
                except Exception as e:
                    print(f"âš ï¸  ÙØ´Ù„ Ø§Ù„Ø£Ù„Ø¨ÙˆÙ…: {e}")
                    return False
            
            async def upload_separately(self, channel, poster_path, video_path, movie_name, video_filename):
                print("\nğŸ“¤ Ø±ÙØ¹ Ù…Ù„ÙÙŠÙ† Ù…Ù†ÙØµÙ„ÙŠÙ†...")
                
                try:
                    print("ğŸ“¸ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©...")
                    await self.client.send_file(
                        channel,
                        poster_path,
                        caption=f"ğŸ¬ {movie_name}\nğŸ“¸ Ø¨ÙˆØ³ØªØ± Ø§Ù„ÙÙŠÙ„Ù…"
                    )
                    
                    print("ğŸ¥ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...")
                    video_size = os.path.getsize(video_path)
                    print(f"ğŸ“Š Ø­Ø¬Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {video_size/(1024*1024):.1f} MB")
                    print("â³ Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ 30-60 Ø¯Ù‚ÙŠÙ‚Ø©...")
                    
                    upload_start = time.time()
                    last_progress = 0
                    
                    def progress_callback(current, total):
                        nonlocal last_progress
                        percent = (current / total) * 100
                        
                        if int(percent) // 10 > last_progress // 10:
                            elapsed = time.time() - upload_start
                            speed = current / elapsed / (1024 * 1024)
                            
                            print(f"ğŸ“¤ Ø±ÙØ¹: {percent:.1f}% | "
                                  f"{current/(1024*1024):.1f} MB | "
                                  f"{speed:.2f} MB/Ø«")
                            last_progress = int(percent)
                    
                    await self.client.send_file(
                        channel,
                        video_path,
                        caption=f"ğŸ¥ {movie_name}\nğŸ“ {video_filename}\nâœ… ÙÙŠÙ„Ù… ÙƒØ§Ù…Ù„",
                        progress_callback=progress_callback,
                        supports_streaming=True,
                        file_name=video_filename,
                        part_size_kb=512,
                        attributes=[
                            types.DocumentAttributeVideo(
                                duration=0,
                                w=0,
                                h=0,
                                round_message=False,
                                supports_streaming=True
                            )
                        ]
                    )
                    
                    upload_time = time.time() - upload_start
                    print(f"âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙÙŠ {upload_time/60:.1f} Ø¯Ù‚ÙŠÙ‚Ø©")
                    return True
                    
                except Exception as e:
                    print(f"âŒ Ø®Ø·Ø£: {e}")
                    return False
            
            async def run(self, config):
                try:
                    if not await self.connect_telegram(
                        config['api_id'],
                        config['api_hash'],
                        config['session_string']
                    ):
                        return False
                    
                    print("\nğŸ“¢ Ø¬Ø§Ø±ÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù‚Ù†Ø§Ø©...")
                    try:
                        channel = await self.client.get_entity(config['channel_link'])
                        print(f"âœ… Ø§Ù„Ù‚Ù†Ø§Ø©: {channel.title}")
                    except Exception as e:
                        print(f"âŒ Ø®Ø·Ø£: {e}")
                        return False
                    
                    clean_name = self.clean_filename(config['movie_name'])
                    video_filename = f"{clean_name}.mp4"
                    print(f"ğŸ“ Ø§Ø³Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ù…Ø¹Ø¯Ù„: {video_filename}")
                    
                    print("\nâ¬‡ï¸  ØªÙ†Ø²ÙŠÙ„ Ø§Ù„Ù…Ù„ÙØ§Øª...")
                    
                    poster_path = "poster.jpg"
                    video_path = "movie.mp4"
                    
                    if not await self.download_file(config['poster_url'], poster_path):
                        return False
                    
                    if not await self.download_file(config['video_url'], video_path):
                        return False
                    
                    success = await self.upload_as_album(
                        channel, poster_path, video_path, 
                        config['movie_name'], video_filename
                    )
                    
                    if not success:
                        print("\nğŸ”„ Ø¬Ø±Ø¨ Ø·Ø±ÙŠÙ‚Ø© Ø§Ù„Ø±ÙØ¹ Ø§Ù„Ù…Ù†ÙØµÙ„...")
                        success = await self.upload_separately(
                            channel, poster_path, video_path,
                            config['movie_name'], video_filename
                        )
                    
                    return success
                    
                except Exception as e:
                    print(f"\nğŸ’¥ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {type(e).__name__}")
                    print(f"ğŸ“ {str(e)[:200]}")
                    return False
                    
                finally:
                    for file in [poster_path, video_path]:
                        if os.path.exists(file):
                            os.remove(file)
                            print(f"ğŸ—‘ï¸  ØªÙ… Ø­Ø°Ù: {file}")
                    
                    if self.client:
                        await self.client.disconnect()
                        print("\nğŸ”’ ØªÙ… Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„")
        
        async def main():
            config = {
                'api_id': int(os.environ.get('TELEGRAM_API_ID', '0')),
                'api_hash': os.environ.get('TELEGRAM_API_HASH', ''),
                'session_string': os.environ.get('TELEGRAM_SESSION_STRING', ''),
                'channel_link': os.environ.get('CHANNEL_LINK', 'https://t.me/+VvLRMffUCXNlNjRk'),
                'movie_name': os.environ.get('MOVIE_NAME', 'Truth & Treason 2025'),
                'poster_url': os.environ.get('POSTER_URL', 'https://img.downet.net/uploads/U8xQf.webp'),
                'video_url': os.environ.get('VIDEO_URL', '')
            }
            
            print(f"ğŸ¬ Ø§Ù„ÙÙŠÙ„Ù…: {config['movie_name']}")
            print(f"ğŸ‘¤ Ø§Ù„Ø­Ø³Ø§Ø¨: @ELQISEER")
            print("=" * 60)
            
            if not config['video_url']:
                print("âŒ ÙŠØ±Ø¬Ù‰ Ø¥Ø¯Ø®Ø§Ù„ Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠØ¯ÙŠÙˆ")
                return False
            
            uploader = MovieUploader()
            success = await uploader.run(config)
            
            if success:
                print("\n" + "=" * 60)
                print("ğŸ‰ ØªÙ… Ø§Ù„Ø±ÙØ¹ Ø¨Ù†Ø¬Ø§Ø­!")
                print("âœ… Ø§Ù„ØµÙˆØ±Ø© ÙˆØ§Ù„ÙÙŠØ¯ÙŠÙˆ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©")
                print("âœ… Ø§Ø³Ù… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ù…Ø¹Ø¯Ù„")
                print("âœ… Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ÙŠØ¹Ù…Ù„ ÙƒÙ…Ø´ØºÙ„")
                print("=" * 60)
            else:
                print("\nâŒ ÙØ´Ù„ Ø§Ù„Ø±ÙØ¹!")
            
            return success
        
        if __name__ == "__main__":
            try:
                success = asyncio.run(main())
                sys.exit(0 if success else 1)
            except KeyboardInterrupt:
                print("\nâ¹ï¸  ØªÙ… Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ø¹Ù…Ù„ÙŠØ©")
                sys.exit(1)
        EOF
        
        echo "âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³ÙƒØ±Ø¨Øª"
        
    - name: âš¡ ØªØ´ØºÙŠÙ„ Ø§Ù„Ø±ÙØ¹
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION_STRING: ${{ secrets.TELEGRAM_SESSION_STRING }}
        CHANNEL_LINK: ${{ github.event.inputs.channel_link }}
        MOVIE_NAME: ${{ github.event.inputs.movie_name }}
        POSTER_URL: ${{ github.event.inputs.poster_url }}
        VIDEO_URL: ${{ github.event.inputs.video_url }}
      run: |
        echo "âš¡ Ø¨Ø¯Ø¡ Ø¹Ù…Ù„ÙŠØ© Ø§Ù„Ø±ÙØ¹..."
        echo "========================================"
        python3 upload_final.py
        echo "========================================"
