# .github/workflows/telegram-uploader.yml
name: ğŸ¬ Telegram Uploader - Fixed

on:
  workflow_dispatch:
    inputs:
      action_type:
        description: 'Ù†ÙˆØ¹ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡'
        required: true
        default: 'upload_poster'
        type: choice
        options:
        - upload_poster      # Ø±ÙØ¹ Ø¨ÙˆØ³ØªØ± ÙÙ‚Ø·
        - upload_movie       # Ø±ÙØ¹ ÙÙŠÙ„Ù… ÙÙ‚Ø·
        - test_connection    # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„
      channel_link:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„Ù‚Ù†Ø§Ø© (Ø¯Ø¹ÙˆØ© Ø£Ùˆ Ù…Ø¹Ø±Ù)'
        required: true
        default: 'https://t.me/+VvLRMffUCXNlNjRk'
        type: string
      movie_name:
        description: 'Ø§Ø³Ù… Ø§Ù„ÙÙŠÙ„Ù…'
        required: true
        default: 'Truth & Treason 2025'
        type: string
      poster_url:
        description: 'Ø±Ø§Ø¨Ø· Ø¨ÙˆØ³ØªØ± Ø§Ù„ÙÙŠÙ„Ù… (ØµÙˆØ±Ø©)'
        required: false
        default: 'https://img.downet.net/uploads/U8xQf.webp'
        type: string
      movie_url:
        description: 'Ø±Ø§Ø¨Ø· Ø§Ù„ÙÙŠÙ„Ù… (.mp4)'
        required: false
        type: string

jobs:
  upload:
    runs-on: ubuntu-latest
    
    steps:
    - name: ğŸ“‹ Ù…Ø¹Ù„ÙˆÙ…Ø§Øª Ø§Ù„Ø·Ù„Ø¨
      run: |
        echo "========================================"
        echo "ğŸ¬ Ù†Ø¸Ø§Ù… Ø±ÙØ¹ Ø£ÙÙ„Ø§Ù… Super Movie"
        echo "========================================"
        echo "Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡: ${{ github.event.inputs.action_type }}"
        echo "Ø§Ù„Ù‚Ù†Ø§Ø©: ${{ github.event.inputs.channel_link }}"
        echo "Ø§Ù„ÙÙŠÙ„Ù…: ${{ github.event.inputs.movie_name }}"
        
        if [ "${{ github.event.inputs.action_type }}" = "upload_poster" ]; then
          echo "Ø§Ù„ØµÙˆØ±Ø©: ${{ github.event.inputs.poster_url }}"
        elif [ "${{ github.event.inputs.action_type }}" = "upload_movie" ]; then
          echo "Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: ${{ github.event.inputs.movie_url }}"
        fi
        
        echo "========================================"
    
    - name: âš™ï¸ ØªØ«Ø¨ÙŠØª Ø§Ù„Ù…ØªØ·Ù„Ø¨Ø§Øª
      run: |
        sudo apt-get update
        sudo apt-get install -y python3 python3-pip wget
        pip3 install telethon --quiet
        
    - name: ğŸ“ Ø¥Ù†Ø´Ø§Ø¡ Ø³ÙƒØ±Ø¨Øª Ø°ÙƒÙŠ
      run: |
        cat > smart_uploader.py << 'EOF'
        import asyncio
        import os
        import sys
        import subprocess
        import time
        
        print("ğŸ¤– Smart Telegram Uploader v2.0")
        print("=" * 50)
        
        # Ù‚Ø±Ø§Ø¡Ø© Ø§Ù„Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ø¨ÙŠØ¦ÙŠØ©
        ACTION = os.environ.get('ACTION_TYPE', 'test_connection').strip()
        CHANNEL = os.environ.get('CHANNEL_LINK', '').strip()
        MOVIE_NAME = os.environ.get('MOVIE_NAME', '').strip()
        POSTER_URL = os.environ.get('POSTER_URL', '').strip()
        MOVIE_URL = os.environ.get('MOVIE_URL', '').strip()
        
        # Ù‚Ø±Ø§Ø¡Ø© Secrets
        API_ID = int(os.environ.get('TELEGRAM_API_ID', '0'))
        API_HASH = os.environ.get('TELEGRAM_API_HASH', '').strip()
        SESSION_STRING = os.environ.get('TELEGRAM_SESSION_STRING', '').strip()
        
        print(f"ğŸ¬ Ø§Ù„ÙÙŠÙ„Ù…: {MOVIE_NAME}")
        print(f"ğŸ“‹ Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡: {ACTION}")
        
        if ACTION == 'upload_poster':
            print(f"ğŸ–¼ï¸  Ø§Ù„Ø¨ÙˆØ³ØªØ±: {POSTER_URL[:50]}...")
        elif ACTION == 'upload_movie':
            print(f"ğŸ¥ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {MOVIE_URL[:50]}...")
        
        print("=" * 50)
        
        from telethon import TelegramClient
        from telethon.sessions import StringSession
        
        class TelegramUploader:
            def __init__(self):
                self.client = None
                self.channel = None
            
            async def connect(self):
                """Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Telegram"""
                print("\nğŸ”Œ Ø¬Ø§Ø±ÙŠ Ø§Ù„Ø§ØªØµØ§Ù„ Ø¨Ù€ Telegram...")
                
                try:
                    self.client = TelegramClient(
                        StringSession(SESSION_STRING),
                        API_ID,
                        API_HASH,
                        connection_retries=5,
                        request_retries=3
                    )
                    
                    await self.client.connect()
                    
                    # Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„
                    me = await self.client.get_me()
                    print(f"âœ… Ù…ØªØµÙ„ ÙƒÙ€: {me.first_name} (@{me.username})")
                    print(f"ğŸ“± Ø±Ù‚Ù… Ø§Ù„Ù‡Ø§ØªÙ: {me.phone}")
                    
                    return True
                    
                except Exception as e:
                    print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ø§ØªØµØ§Ù„: {e}")
                    return False
            
            async def get_channel(self):
                """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†Ø§Ø©"""
                print("\nğŸ“¢ Ø¬Ø§Ø±ÙŠ Ø§Ù„ÙˆØµÙˆÙ„ Ù„Ù„Ù‚Ù†Ø§Ø©...")
                
                try:
                    self.channel = await self.client.get_entity(CHANNEL)
                    print(f"âœ… Ø§Ù„Ù‚Ù†Ø§Ø©: {self.channel.title}")
                    return True
                    
                except Exception as e:
                    print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù‚Ù†Ø§Ø©: {e}")
                    return False
            
            async def download_file(self, url, filename, is_video=False):
                """ØªÙ†Ø²ÙŠÙ„ Ù…Ù„Ù"""
                try:
                    if is_video:
                        print(f"\nâ¬‡ï¸  ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ...")
                        cmd = [
                            'wget',
                            '--no-check-certificate',
                            '-c',
                            '--timeout=120',
                            '--tries=5',
                            '--show-progress',
                            '-O', filename,
                            url
                        ]
                    else:
                        print(f"\nâ¬‡ï¸  ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©...")
                        cmd = [
                            'wget',
                            '-q',
                            '--timeout=30',
                            '--tries=3',
                            '-O', filename,
                            url
                        ]
                    
                    result = subprocess.run(cmd, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        if os.path.exists(filename):
                            size = os.path.getsize(filename)
                            print(f"âœ… ØªÙ… Ø§Ù„ØªÙ†Ø²ÙŠÙ„: {filename} ({size/(1024*1024):.1f} MB)")
                            return True
                    
                    print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØªÙ†Ø²ÙŠÙ„: {result.stderr}")
                    return False
                    
                except Exception as e:
                    print(f"âŒ Ø®Ø·Ø£: {e}")
                    return False
            
            async def upload_poster(self):
                """Ø±ÙØ¹ Ø¨ÙˆØ³ØªØ± Ø§Ù„ÙÙŠÙ„Ù…"""
                print("\n" + "=" * 50)
                print("ğŸ“¸ Ø¨Ø¯Ø¡ Ø±ÙØ¹ Ø¨ÙˆØ³ØªØ± Ø§Ù„ÙÙŠÙ„Ù…")
                print("=" * 50)
                
                # ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ØµÙˆØ±Ø©
                if not await self.download_file(POSTER_URL, 'movie_poster.jpg', False):
                    return False
                
                # Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©
                try:
                    print("\nğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØ³ØªØ±...")
                    
                    await self.client.send_file(
                        self.channel,
                        'movie_poster.jpg',
                        caption=f'ğŸ¬ **{MOVIE_NAME}**\nğŸ“¸ Ø¨ÙˆØ³ØªØ± Ø§Ù„ÙÙŠÙ„Ù…\n\nâ³ Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ÙÙŠÙ„Ù…...'
                    )
                    
                    print("âœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„Ø¨ÙˆØ³ØªØ± Ø¨Ù†Ø¬Ø§Ø­!")
                    return True
                    
                except Exception as e:
                    print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ØµÙˆØ±Ø©: {e}")
                    return False
            
            async def upload_movie(self):
                """Ø±ÙØ¹ Ø§Ù„ÙÙŠÙ„Ù…"""
                print("\n" + "=" * 50)
                print("ğŸ¥ Ø¨Ø¯Ø¡ Ø±ÙØ¹ Ø§Ù„ÙÙŠÙ„Ù…")
                print("=" * 50)
                
                # ØªÙ†Ø²ÙŠÙ„ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
                if not await self.download_file(MOVIE_URL, 'full_movie.mp4', True):
                    return False
                
                # Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
                try:
                    file_size = os.path.getsize('full_movie.mp4')
                    print(f"\nğŸ“¤ Ø¬Ø§Ø±ÙŠ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ ({file_size/(1024*1024):.1f} MB)...")
                    print("â³ Ù‚Ø¯ ÙŠØ³ØªØºØ±Ù‚ 30-60 Ø¯Ù‚ÙŠÙ‚Ø©...")
                    
                    start_time = time.time()
                    
                    # Ø¯Ø§Ù„Ø© Ø¹Ø±Ø¶ Ø§Ù„ØªÙ‚Ø¯Ù…
                    def progress_callback(current, total):
                        percent = (current / total) * 100
                        elapsed = time.time() - start_time
                        
                        # ØªØ­Ø¯ÙŠØ« ÙƒÙ„ 10%
                        if int(percent) % 10 == 0:
                            speed = current / elapsed / (1024 * 1024)
                            print(f"   ğŸ“Š {percent:.1f}% | {current/(1024*1024):.1f} MB | {speed:.2f} MB/Ø«")
                    
                    # Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ
                    await self.client.send_file(
                        self.channel,
                        'full_movie.mp4',
                        caption=f'ğŸ¥ **{MOVIE_NAME}**\n'
                               f'ğŸ“Š Ø§Ù„Ø­Ø¬Ù…: {file_size/(1024*1024):.1f} MB\n'
                               f'âœ… Ø§Ù„ÙÙŠÙ„Ù… ÙƒØ§Ù…Ù„\n'
                               f'ğŸ‘¤ ØªÙ… Ø§Ù„Ø±ÙØ¹ Ø¨ÙˆØ§Ø³Ø·Ø© @ELQISEER',
                        progress_callback=progress_callback,
                        supports_streaming=True
                    )
                    
                    upload_time = time.time() - start_time
                    print(f"\nâœ… ØªÙ… Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ Ø¨Ù†Ø¬Ø§Ø­!")
                    print(f"â±ï¸  Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ø¥Ø¬Ù…Ø§Ù„ÙŠ: {upload_time/60:.1f} Ø¯Ù‚ÙŠÙ‚Ø©")
                    
                    return True
                    
                except Exception as e:
                    print(f"âŒ Ø®Ø·Ø£ ÙÙŠ Ø±ÙØ¹ Ø§Ù„ÙÙŠØ¯ÙŠÙˆ: {e}")
                    return False
            
            async def cleanup(self):
                """ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ù…Ù„ÙØ§Øª"""
                files_to_clean = ['movie_poster.jpg', 'full_movie.mp4']
                for file in files_to_clean:
                    if os.path.exists(file):
                        os.remove(file)
                        print(f"ğŸ—‘ï¸  ØªÙ… Ø­Ø°Ù: {file}")
            
            async def disconnect(self):
                """Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„"""
                if self.client:
                    await self.client.disconnect()
                    print("\nğŸ”’ ØªÙ… Ù‚Ø·Ø¹ Ø§Ù„Ø§ØªØµØ§Ù„")
        
        async def main():
            uploader = TelegramUploader()
            
            try:
                # 1. Ø§Ù„Ø§ØªØµØ§Ù„
                if not await uploader.connect():
                    return False
                
                # 2. Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ø§Ù„Ù‚Ù†Ø§Ø©
                if not await uploader.get_channel():
                    return False
                
                # 3. ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡ Ø§Ù„Ù…Ø·Ù„ÙˆØ¨
                if ACTION == 'test_connection':
                    print("\nâœ… Ø§Ø®ØªØ¨Ø§Ø± Ø§Ù„Ø§ØªØµØ§Ù„ Ù†Ø§Ø¬Ø­!")
                    success = True
                    
                elif ACTION == 'upload_poster':
                    success = await uploader.upload_poster()
                    
                elif ACTION == 'upload_movie':
                    success = await uploader.upload_movie()
                    
                else:
                    print(f"âŒ Ø¥Ø¬Ø±Ø§Ø¡ ØºÙŠØ± Ù…Ø¹Ø±ÙˆÙ: {ACTION}")
                    success = False
                
                return success
                
            except Exception as e:
                print(f"\nğŸ’¥ Ø®Ø·Ø£ ØºÙŠØ± Ù…ØªÙˆÙ‚Ø¹: {type(e).__name__}")
                print(f"ğŸ“ {str(e)}")
                return False
                
            finally:
                # ØªÙ†Ø¸ÙŠÙ Ø¯Ø§Ø¦Ù…
                await uploader.cleanup()
                await uploader.disconnect()
        
        # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨Ø±Ù†Ø§Ù…Ø¬
        if __name__ == "__main__":
            success = asyncio.run(main())
            sys.exit(0 if success else 1)
        EOF
        
        echo "âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ø³ÙƒØ±Ø¨Øª Ø§Ù„Ø°ÙƒÙŠ"
        
    - name: âš¡ ØªÙ†ÙÙŠØ° Ø§Ù„Ø¥Ø¬Ø±Ø§Ø¡
      env:
        TELEGRAM_API_ID: ${{ secrets.TELEGRAM_API_ID }}
        TELEGRAM_API_HASH: ${{ secrets.TELEGRAM_API_HASH }}
        TELEGRAM_SESSION_STRING: ${{ secrets.TELEGRAM_SESSION_STRING }}
        ACTION_TYPE: ${{ github.event.inputs.action_type }}
        CHANNEL_LINK: ${{ github.event.inputs.channel_link }}
        MOVIE_NAME: ${{ github.event.inputs.movie_name }}
        POSTER_URL: ${{ github.event.inputs.poster_url }}
        MOVIE_URL: ${{ github.event.inputs.movie_url }}
      run: |
        echo "âš¡ ØªÙ†ÙÙŠØ°: ${{ github.event.inputs.action_type }}"
        echo "========================================"
        python3 smart_uploader.py
        echo "========================================"
        
    - name: ğŸ“Š Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
      if: always()
      run: |
        echo "ğŸ Ø§Ù„Ø¹Ù…Ù„ÙŠØ© Ø§ÙƒØªÙ…Ù„Øª!"
        echo "ğŸ•’ Ø§Ù„ÙˆÙ‚Øª: $(date '+%H:%M:%S')"
        echo "========================================"
